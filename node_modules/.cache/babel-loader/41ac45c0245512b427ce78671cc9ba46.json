{"ast":null,"code":"var _jsxFileName = \"/home/raguram_s/Desktop/lister/src/components/Wheel.js\";\nimport React from 'react';\nimport Card from './Card.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass Wheel extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.children_loaded = () => {\n      this.setState(prevState => {\n        return {\n          children_loaded: prevState.children_loaded + 1\n        };\n      }, () => {\n        if (this.state.children_loaded === 8) {\n          this.setState({\n            loaded: true,\n            snap_point: {\n              x: this.wheel.children[2].getBoundingClientRect().x + this.wheel.children[2].getBoundingClientRect().width / 2,\n              y: this.wheel.children[2].getBoundingClientRect().y + this.wheel.children[2].getBoundingClientRect().height / 2\n            }\n          });\n        }\n      });\n    };\n\n    this.snap_back = () => {\n      let center_of_wheel = {\n        x: this.wheel.getBoundingClientRect().x + this.wheel.getBoundingClientRect().width / 2,\n        y: this.wheel.getBoundingClientRect().y + this.wheel.getBoundingClientRect().height / 2\n      };\n      let snap_point_theta = Math.atan2(Math.abs(this.state.snap_point.y - center_of_wheel.y), Math.abs(this.state.snap_point.x - center_of_wheel.x));\n      snap_point_theta = snap_point_theta * (180 / Math.PI);\n      let shortest_distance = Math.pow(this.wheel.children[3].getBoundingClientRect().x + 100 - this.state.snap_point.x, 2) + Math.pow(this.wheel.children[3].getBoundingClientRect().y + 100 - this.state.snap_point.y, 2);\n      shortest_distance = Math.sqrt(shortest_distance);\n      let closest_card = null; // loop through all cards and compare distances to snap_point; find shortest distance\n\n      for (let i = 0; i < this.wheel.children.length; i++) {\n        let dx = this.wheel.children[i].getBoundingClientRect().x + 100 - this.state.snap_point.x;\n        let dy = this.wheel.children[i].getBoundingClientRect().y + 100 - this.state.snap_point.y;\n        let current_distance = Math.pow(dx, 2) + Math.pow(dy, 2);\n        current_distance = Math.sqrt(current_distance);\n\n        if (shortest_distance >= current_distance) {\n          shortest_distance = current_distance;\n          closest_card = this.wheel.children[i];\n        }\n      } // find angle between snap_point's theta and closest_card's theta\n\n\n      let closest_cards_x = closest_card.getBoundingClientRect().x + closest_card.getBoundingClientRect().width / 2;\n      let closest_cards_y = closest_card.getBoundingClientRect().y + closest_card.getBoundingClientRect().height / 2;\n      let closest_cards_theta = Math.atan2(Math.abs(closest_cards_y - center_of_wheel.y), Math.abs(closest_cards_x - center_of_wheel.x));\n      closest_cards_theta = closest_cards_theta * (180 / Math.PI);\n      let theta_between = Math.abs(closest_cards_theta - snap_point_theta); // decide whether to make a positive or negative degree shift\n\n      if (closest_cards_x > center_of_wheel.x && closest_cards_y <= center_of_wheel.y) {\n        // QI\n        theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n      } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y <= center_of_wheel.y) {\n        // QII\n        theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n      } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y > center_of_wheel.y) {\n        // QIII\n        theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n      } else if (closest_cards_x > center_of_wheel.x && closest_cards_y >= center_of_wheel.y) {\n        // QIV\n        theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n      } // rotate wheel towards snap point\n\n\n      this.wheel.style.transitionDelay = '0.1s';\n      this.wheel.style.transitionDuration = '1.0s';\n      this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.state.theta + theta_between}deg)`; // rotate the cards in the opposite direction of the wheel to maintain equilibrium\n\n      for (let i = 0; i < this.wheel.children.length; i++) {\n        this.wheel.children[i].style.transitionDelay = '0.1s';\n        this.wheel.children[i].style.transitionDuration = '1.0s';\n\n        if (closest_card === this.wheel.children[i]) {\n          this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(1.0)`;\n          this.wheel.children[i].style.zIndex = 100;\n        } else {\n          this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(0.5)`;\n          this.wheel.children[i].style.zIndex = 1;\n        }\n      }\n\n      setTimeout(() => {\n        this.setState(prevState => {\n          return {\n            snap_in_progress: false,\n            theta: prevState.theta + theta_between\n          };\n        });\n      }, 200);\n    };\n\n    this.state = {\n      radius: 150,\n      cards: [],\n      theta: 0.0,\n      snap_point: {\n        x: null,\n        y: null\n      },\n      snap_in_progress: false,\n      children_loaded: 0,\n      loaded: false\n    };\n    this.temp_theta = 0.0;\n    this.anim_id = null;\n  }\n\n  componentDidMount() {\n    let center_of_wheel = {\n      x: parseFloat(this.wheel.style.width) / 2,\n      y: parseFloat(this.wheel.style.height) / 2\n    };\n    let temp_cards = [];\n\n    for (let i = 0; i < 8; i++) {\n      temp_cards.push(\n      /*#__PURE__*/\n      // <Card radius={this.state.radius} theta={(Math.PI / 4) * i} center={center_of_wheel} key={`card_${i}`} pic={`./${i}-200x200.jpg`} amLoaded={this.children_loaded} />\n      _jsxDEV(Card, {\n        radius: this.state.radius,\n        theta: Math.PI / 4 * i,\n        center: center_of_wheel,\n        pic: `https://picsum.photos/500/500`,\n        amLoaded: this.children_loaded\n      }, `card_${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 17\n      }, this));\n    }\n\n    this.setState({\n      cards: temp_cards\n    });\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      onWheel: this.handle_scroll,\n      ref: ref_id => this.wheel = ref_id,\n      style: styles.wheel,\n      children: this.state.cards\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 13\n    }, this);\n  }\n\n}\n\nconst styles = {\n  wheel: {\n    margin: '70px',\n    height: '100px',\n    width: '100px',\n    borderRadius: '50%',\n    position: 'absolute',\n    transform: 'translate(-50%, -50%)',\n    backgroundColor: '#EF6E25'\n  }\n};\nexport default Wheel;","map":{"version":3,"sources":["/home/raguram_s/Desktop/lister/src/components/Wheel.js"],"names":["React","Card","Wheel","Component","constructor","props","children_loaded","setState","prevState","state","loaded","snap_point","x","wheel","children","getBoundingClientRect","width","y","height","snap_back","center_of_wheel","snap_point_theta","Math","atan2","abs","PI","shortest_distance","pow","sqrt","closest_card","i","length","dx","dy","current_distance","closest_cards_x","closest_cards_y","closest_cards_theta","theta_between","style","transitionDelay","transitionDuration","transform","theta","zIndex","setTimeout","snap_in_progress","radius","cards","temp_theta","anim_id","componentDidMount","parseFloat","temp_cards","push","render","handle_scroll","ref_id","styles","margin","borderRadius","position","backgroundColor"],"mappings":"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","sourcesContent":["import React from 'react'\n\nimport Card from './Card.js';\n\n\nclass Wheel extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            radius: 150,\n            cards: [],\n            theta: 0.0,\n            snap_point: { x: null, y: null },\n            snap_in_progress: false,\n            children_loaded: 0,\n            loaded: false,\n        }\n\n        this.temp_theta = 0.0;\n        this.anim_id = null;\n    }\n\n    componentDidMount() {\n        let center_of_wheel = {\n            x: parseFloat(this.wheel.style.width) / 2,\n            y: parseFloat(this.wheel.style.height) / 2\n        }\n        let temp_cards = [];\n\n        for (let i = 0; i < 8; i++) {\n            temp_cards.push(\n                // <Card radius={this.state.radius} theta={(Math.PI / 4) * i} center={center_of_wheel} key={`card_${i}`} pic={`./${i}-200x200.jpg`} amLoaded={this.children_loaded} />\n                <Card radius={this.state.radius} theta={(Math.PI / 4) * i} center={center_of_wheel} key={`card_${i}`} pic={`https://picsum.photos/500/500`} amLoaded={this.children_loaded} />\n            );\n        }\n\n        this.setState({ cards: temp_cards });\n    }\n\n    \n\n    children_loaded = () => {\n        this.setState(prevState => {\n            return {\n                children_loaded: prevState.children_loaded + 1\n            }\n        }, () => {\n            if (this.state.children_loaded === 8) {\n                this.setState({\n                    loaded: true,\n                    snap_point: {\n                        x: this.wheel.children[2].getBoundingClientRect().x + (this.wheel.children[2].getBoundingClientRect().width / 2),\n                        y: this.wheel.children[2].getBoundingClientRect().y + (this.wheel.children[2].getBoundingClientRect().height / 2),\n                    }\n                });\n            }\n        });\n    }\n\n    snap_back = () => {\n        let center_of_wheel = {\n            x: this.wheel.getBoundingClientRect().x + (this.wheel.getBoundingClientRect().width / 2),\n            y: this.wheel.getBoundingClientRect().y + (this.wheel.getBoundingClientRect().height / 2)\n        }\n        let snap_point_theta = Math.atan2(Math.abs(this.state.snap_point.y - center_of_wheel.y), Math.abs(this.state.snap_point.x - center_of_wheel.x));\n        snap_point_theta = snap_point_theta * (180 / Math.PI);\n\n        let shortest_distance =\n            Math.pow(((this.wheel.children[3].getBoundingClientRect().x + 100) - this.state.snap_point.x), 2) +\n            Math.pow(((this.wheel.children[3].getBoundingClientRect().y + 100) - this.state.snap_point.y), 2);\n        shortest_distance = Math.sqrt(shortest_distance);\n\n        let closest_card = null;\n\n        // loop through all cards and compare distances to snap_point; find shortest distance\n        for (let i = 0; i < this.wheel.children.length; i++) {\n            let dx = (this.wheel.children[i].getBoundingClientRect().x + 100) - this.state.snap_point.x;\n            let dy = (this.wheel.children[i].getBoundingClientRect().y + 100) - this.state.snap_point.y;\n            let current_distance = Math.pow(dx, 2) + Math.pow(dy, 2);\n            current_distance = Math.sqrt(current_distance)\n\n            if (shortest_distance >= current_distance) {\n                shortest_distance = current_distance;\n                closest_card = this.wheel.children[i];\n            }\n        }\n\n        // find angle between snap_point's theta and closest_card's theta\n        let closest_cards_x = closest_card.getBoundingClientRect().x + (closest_card.getBoundingClientRect().width / 2);\n        let closest_cards_y = closest_card.getBoundingClientRect().y + (closest_card.getBoundingClientRect().height / 2);\n\n        let closest_cards_theta = Math.atan2(Math.abs(closest_cards_y - center_of_wheel.y), Math.abs(closest_cards_x - center_of_wheel.x));\n        closest_cards_theta = closest_cards_theta * (180 / Math.PI);\n\n        let theta_between = Math.abs(closest_cards_theta - snap_point_theta);\n\n        // decide whether to make a positive or negative degree shift\n        if (closest_cards_x > center_of_wheel.x && closest_cards_y <= center_of_wheel.y) { // QI\n            theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n        } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y <= center_of_wheel.y) { // QII\n            theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n        } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y > center_of_wheel.y) { // QIII\n            theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n        } else if (closest_cards_x > center_of_wheel.x && closest_cards_y >= center_of_wheel.y) { // QIV\n            theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n        }\n\n        // rotate wheel towards snap point\n        this.wheel.style.transitionDelay = '0.1s';\n        this.wheel.style.transitionDuration = '1.0s';\n        this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.state.theta + theta_between}deg)`;\n\n        // rotate the cards in the opposite direction of the wheel to maintain equilibrium\n        for (let i = 0; i < this.wheel.children.length; i++) {\n            this.wheel.children[i].style.transitionDelay = '0.1s';\n            this.wheel.children[i].style.transitionDuration = '1.0s';\n\n            if (closest_card === this.wheel.children[i]) {\n                this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(1.0)`;\n                this.wheel.children[i].style.zIndex = 100;\n            } else {\n                this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(0.5)`;\n                this.wheel.children[i].style.zIndex = 1;\n            }\n        }\n\n        setTimeout(() => {\n            this.setState(prevState => {\n                return {\n                    snap_in_progress: false,\n                    theta: prevState.theta + theta_between\n                }\n            });\n        }, 200);\n    }\n\n    render() {\n        return (\n            <div onWheel={this.handle_scroll} ref={ref_id => this.wheel = ref_id} style={styles.wheel}>\n                {this.state.cards}\n            </div>\n        )\n\n    }\n}\n\nconst styles = {\n    wheel: {\n        margin:'70px',\n        height: '100px',\n        width: '100px',\n        borderRadius: '50%',\n        position: 'absolute',\n        transform: 'translate(-50%, -50%)',\n        backgroundColor: '#EF6E25'\n    }\n}\n\nexport default Wheel;"]},"metadata":{},"sourceType":"module"}