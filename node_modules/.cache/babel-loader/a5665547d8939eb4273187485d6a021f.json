{"ast":null,"code":"var _jsxFileName = \"/home/raguram_s/Desktop/lister/src/components/Wheel.js\";\nimport React from 'react';\nimport Card from './Card.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass Wheel extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.handle_scroll = event => {\n      if (this.state.snap_in_progress && !this.state.loaded) {\n        return;\n      } else {\n        clearTimeout(this.anim_id);\n        let scroll_speed = event.deltaY / 360 * 20;\n        this.temp_theta += scroll_speed;\n        this.wheel.style.transitionDelay = '0.0s';\n        this.wheel.style.transitionDuration = '0.0s';\n        this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.temp_theta}deg)`; // this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.temp_theta + (event.deltaY * 0.5)}deg)`;\n        // this.temp_theta += (event.deltaY * 0.5);\n        // rotate the cards in the opposite direction of the wheel to maintain equilibrium\n\n        for (let i = 0; i < this.wheel.children.length; i++) {\n          this.wheel.children[i].style.transitionDelay = '0.0s';\n          this.wheel.children[i].style.transitionDuration = '0.0s';\n          this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * this.temp_theta}deg)`;\n        }\n\n        this.anim_id = setTimeout(() => {\n          this.setState({\n            theta: this.temp_theta,\n            snap_in_progress: true\n          }, () => {\n            this.snap_back();\n          });\n        }, 150);\n      }\n    };\n\n    this.children_loaded = () => {\n      this.setState(prevState => {\n        return {\n          children_loaded: prevState.children_loaded + 1\n        };\n      }, () => {\n        if (this.state.children_loaded === 8) {\n          this.setState({\n            loaded: true,\n            snap_point: {\n              x: this.wheel.children[2].getBoundingClientRect().x + this.wheel.children[2].getBoundingClientRect().width / 2,\n              y: this.wheel.children[2].getBoundingClientRect().y + this.wheel.children[2].getBoundingClientRect().height / 2\n            }\n          });\n        }\n      });\n    };\n\n    this.snap_back = () => {\n      let center_of_wheel = {\n        x: this.wheel.getBoundingClientRect().x + this.wheel.getBoundingClientRect().width / 2,\n        y: this.wheel.getBoundingClientRect().y + this.wheel.getBoundingClientRect().height / 2\n      };\n      let snap_point_theta = Math.atan2(Math.abs(this.state.snap_point.y - center_of_wheel.y), Math.abs(this.state.snap_point.x - center_of_wheel.x));\n      snap_point_theta = snap_point_theta * (180 / Math.PI);\n      let shortest_distance = Math.pow(this.wheel.children[3].getBoundingClientRect().x + 100 - this.state.snap_point.x, 2) + Math.pow(this.wheel.children[3].getBoundingClientRect().y + 100 - this.state.snap_point.y, 2);\n      shortest_distance = Math.sqrt(shortest_distance);\n      let closest_card = null; // loop through all cards and compare distances to snap_point; find shortest distance\n\n      for (let i = 0; i < this.wheel.children.length; i++) {\n        let dx = this.wheel.children[i].getBoundingClientRect().x + 100 - this.state.snap_point.x;\n        let dy = this.wheel.children[i].getBoundingClientRect().y + 100 - this.state.snap_point.y;\n        let current_distance = Math.pow(dx, 2) + Math.pow(dy, 2);\n        current_distance = Math.sqrt(current_distance);\n\n        if (shortest_distance >= current_distance) {\n          shortest_distance = current_distance;\n          closest_card = this.wheel.children[i];\n        }\n      } // find angle between snap_point's theta and closest_card's theta\n\n\n      let closest_cards_x = closest_card.getBoundingClientRect().x + closest_card.getBoundingClientRect().width / 2;\n      let closest_cards_y = closest_card.getBoundingClientRect().y + closest_card.getBoundingClientRect().height / 2;\n      let closest_cards_theta = Math.atan2(Math.abs(closest_cards_y - center_of_wheel.y), Math.abs(closest_cards_x - center_of_wheel.x));\n      closest_cards_theta = closest_cards_theta * (180 / Math.PI);\n      let theta_between = Math.abs(closest_cards_theta - snap_point_theta); // decide whether to make a positive or negative degree shift\n\n      if (closest_cards_x > center_of_wheel.x && closest_cards_y <= center_of_wheel.y) {\n        // QI\n        theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n      } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y <= center_of_wheel.y) {\n        // QII\n        theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n      } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y > center_of_wheel.y) {\n        // QIII\n        theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n      } else if (closest_cards_x > center_of_wheel.x && closest_cards_y >= center_of_wheel.y) {\n        // QIV\n        theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n      } // rotate wheel towards snap point\n\n\n      this.wheel.style.transitionDelay = '0.1s';\n      this.wheel.style.transitionDuration = '1.0s';\n      this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.state.theta + theta_between}deg)`; // rotate the cards in the opposite direction of the wheel to maintain equilibrium\n\n      for (let i = 0; i < this.wheel.children.length; i++) {\n        this.wheel.children[i].style.transitionDelay = '0.1s';\n        this.wheel.children[i].style.transitionDuration = '1.0s';\n\n        if (closest_card === this.wheel.children[i]) {\n          this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(1.0)`;\n          this.wheel.children[i].style.zIndex = 100;\n        } else {\n          this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(0.5)`;\n          this.wheel.children[i].style.zIndex = 1;\n        }\n      }\n\n      setTimeout(() => {\n        this.setState(prevState => {\n          return {\n            snap_in_progress: false,\n            theta: prevState.theta + theta_between\n          };\n        });\n      }, 200);\n    };\n\n    this.state = {\n      radius: 150,\n      cards: [],\n      theta: 0.0,\n      snap_point: {\n        x: null,\n        y: null\n      },\n      snap_in_progress: false,\n      children_loaded: 0,\n      loaded: false\n    };\n    this.temp_theta = 0.0;\n    this.anim_id = null;\n  }\n\n  componentDidMount() {\n    let center_of_wheel = {\n      x: parseFloat(this.wheel.style.width) / 2,\n      y: parseFloat(this.wheel.style.height) / 2\n    };\n    let temp_cards = [];\n\n    for (let i = 0; i < 8; i++) {\n      temp_cards.push(\n      /*#__PURE__*/\n      // <Card radius={this.state.radius} theta={(Math.PI / 4) * i} center={center_of_wheel} key={`card_${i}`} pic={`./${i}-200x200.jpg`} amLoaded={this.children_loaded} />\n      _jsxDEV(Card, {\n        radius: this.state.radius,\n        theta: Math.PI / 4 * i,\n        center: center_of_wheel,\n        pic: `https://picsum.photos/500/500`,\n        amLoaded: this.children_loaded\n      }, `card_${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 17\n      }, this));\n    }\n\n    this.setState({\n      cards: temp_cards\n    });\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      onWheel: this.handle_scroll,\n      ref: ref_id => this.wheel = ref_id,\n      style: styles.wheel,\n      children: this.state.cards\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 166,\n      columnNumber: 13\n    }, this);\n  }\n\n}\n\nconst styles = {\n  wheel: {\n    margin: '100px',\n    height: '100px',\n    width: '100px',\n    borderRadius: '50%',\n    position: 'absolute',\n    transform: 'translate(-50%, -50%)',\n    backgroundColor: 'orange'\n  }\n};\nexport default Wheel;","map":{"version":3,"sources":["/home/raguram_s/Desktop/lister/src/components/Wheel.js"],"names":["React","Card","Wheel","Component","constructor","props","handle_scroll","event","state","snap_in_progress","loaded","clearTimeout","anim_id","scroll_speed","deltaY","temp_theta","wheel","style","transitionDelay","transitionDuration","transform","i","children","length","setTimeout","setState","theta","snap_back","children_loaded","prevState","snap_point","x","getBoundingClientRect","width","y","height","center_of_wheel","snap_point_theta","Math","atan2","abs","PI","shortest_distance","pow","sqrt","closest_card","dx","dy","current_distance","closest_cards_x","closest_cards_y","closest_cards_theta","theta_between","zIndex","radius","cards","componentDidMount","parseFloat","temp_cards","push","render","ref_id","styles","margin","borderRadius","position","backgroundColor"],"mappings":"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","sourcesContent":["import React from 'react'\n\nimport Card from './Card.js';\n\n\nclass Wheel extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            radius: 150,\n            cards: [],\n            theta: 0.0,\n            snap_point: { x: null, y: null },\n            snap_in_progress: false,\n            children_loaded: 0,\n            loaded: false,\n        }\n\n        this.temp_theta = 0.0;\n        this.anim_id = null;\n    }\n\n    componentDidMount() {\n        let center_of_wheel = {\n            x: parseFloat(this.wheel.style.width) / 2,\n            y: parseFloat(this.wheel.style.height) / 2\n        }\n        let temp_cards = [];\n\n        for (let i = 0; i < 8; i++) {\n            temp_cards.push(\n                // <Card radius={this.state.radius} theta={(Math.PI / 4) * i} center={center_of_wheel} key={`card_${i}`} pic={`./${i}-200x200.jpg`} amLoaded={this.children_loaded} />\n                <Card radius={this.state.radius} theta={(Math.PI / 4) * i} center={center_of_wheel} key={`card_${i}`} pic={`https://picsum.photos/500/500`} amLoaded={this.children_loaded} />\n            );\n        }\n\n        this.setState({ cards: temp_cards });\n    }\n\n    handle_scroll = event => {\n        if (this.state.snap_in_progress && !this.state.loaded) {\n            return;\n        } else {\n            clearTimeout(this.anim_id);\n            let scroll_speed = (event.deltaY / 360) * 20;\n            this.temp_theta += scroll_speed;\n            this.wheel.style.transitionDelay = '0.0s';\n            this.wheel.style.transitionDuration = '0.0s';\n            this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.temp_theta}deg)`;\n            // this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.temp_theta + (event.deltaY * 0.5)}deg)`;\n            // this.temp_theta += (event.deltaY * 0.5);\n\n            // rotate the cards in the opposite direction of the wheel to maintain equilibrium\n            for (let i = 0; i < this.wheel.children.length; i++) {\n                this.wheel.children[i].style.transitionDelay = '0.0s';\n                this.wheel.children[i].style.transitionDuration = '0.0s';\n                this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * this.temp_theta}deg)`;\n            }\n\n            this.anim_id = setTimeout(() => {\n                this.setState({ theta: this.temp_theta, snap_in_progress: true }, () => {\n                    this.snap_back();\n                });\n            }, 150);\n        }\n    }\n\n    children_loaded = () => {\n        this.setState(prevState => {\n            return {\n                children_loaded: prevState.children_loaded + 1\n            }\n        }, () => {\n            if (this.state.children_loaded === 8) {\n                this.setState({\n                    loaded: true,\n                    snap_point: {\n                        x: this.wheel.children[2].getBoundingClientRect().x + (this.wheel.children[2].getBoundingClientRect().width / 2),\n                        y: this.wheel.children[2].getBoundingClientRect().y + (this.wheel.children[2].getBoundingClientRect().height / 2),\n                    }\n                });\n            }\n        });\n    }\n\n    snap_back = () => {\n        let center_of_wheel = {\n            x: this.wheel.getBoundingClientRect().x + (this.wheel.getBoundingClientRect().width / 2),\n            y: this.wheel.getBoundingClientRect().y + (this.wheel.getBoundingClientRect().height / 2)\n        }\n        let snap_point_theta = Math.atan2(Math.abs(this.state.snap_point.y - center_of_wheel.y), Math.abs(this.state.snap_point.x - center_of_wheel.x));\n        snap_point_theta = snap_point_theta * (180 / Math.PI);\n\n        let shortest_distance =\n            Math.pow(((this.wheel.children[3].getBoundingClientRect().x + 100) - this.state.snap_point.x), 2) +\n            Math.pow(((this.wheel.children[3].getBoundingClientRect().y + 100) - this.state.snap_point.y), 2);\n        shortest_distance = Math.sqrt(shortest_distance);\n\n        let closest_card = null;\n\n        // loop through all cards and compare distances to snap_point; find shortest distance\n        for (let i = 0; i < this.wheel.children.length; i++) {\n            let dx = (this.wheel.children[i].getBoundingClientRect().x + 100) - this.state.snap_point.x;\n            let dy = (this.wheel.children[i].getBoundingClientRect().y + 100) - this.state.snap_point.y;\n            let current_distance = Math.pow(dx, 2) + Math.pow(dy, 2);\n            current_distance = Math.sqrt(current_distance)\n\n            if (shortest_distance >= current_distance) {\n                shortest_distance = current_distance;\n                closest_card = this.wheel.children[i];\n            }\n        }\n\n        // find angle between snap_point's theta and closest_card's theta\n        let closest_cards_x = closest_card.getBoundingClientRect().x + (closest_card.getBoundingClientRect().width / 2);\n        let closest_cards_y = closest_card.getBoundingClientRect().y + (closest_card.getBoundingClientRect().height / 2);\n\n        let closest_cards_theta = Math.atan2(Math.abs(closest_cards_y - center_of_wheel.y), Math.abs(closest_cards_x - center_of_wheel.x));\n        closest_cards_theta = closest_cards_theta * (180 / Math.PI);\n\n        let theta_between = Math.abs(closest_cards_theta - snap_point_theta);\n\n        // decide whether to make a positive or negative degree shift\n        if (closest_cards_x > center_of_wheel.x && closest_cards_y <= center_of_wheel.y) { // QI\n            theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n        } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y <= center_of_wheel.y) { // QII\n            theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n        } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y > center_of_wheel.y) { // QIII\n            theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n        } else if (closest_cards_x > center_of_wheel.x && closest_cards_y >= center_of_wheel.y) { // QIV\n            theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n        }\n\n        // rotate wheel towards snap point\n        this.wheel.style.transitionDelay = '0.1s';\n        this.wheel.style.transitionDuration = '1.0s';\n        this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.state.theta + theta_between}deg)`;\n\n        // rotate the cards in the opposite direction of the wheel to maintain equilibrium\n        for (let i = 0; i < this.wheel.children.length; i++) {\n            this.wheel.children[i].style.transitionDelay = '0.1s';\n            this.wheel.children[i].style.transitionDuration = '1.0s';\n\n            if (closest_card === this.wheel.children[i]) {\n                this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(1.0)`;\n                this.wheel.children[i].style.zIndex = 100;\n            } else {\n                this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(0.5)`;\n                this.wheel.children[i].style.zIndex = 1;\n            }\n        }\n\n        setTimeout(() => {\n            this.setState(prevState => {\n                return {\n                    snap_in_progress: false,\n                    theta: prevState.theta + theta_between\n                }\n            });\n        }, 200);\n    }\n\n    render() {\n        return (\n            <div onWheel={this.handle_scroll} ref={ref_id => this.wheel = ref_id} style={styles.wheel}>\n                {this.state.cards}\n            </div>\n        )\n\n    }\n}\n\nconst styles = {\n    wheel: {\n        margin:'100px',\n        height: '100px',\n        width: '100px',\n        borderRadius: '50%',\n        position: 'absolute',\n        transform: 'translate(-50%, -50%)',\n        backgroundColor: 'orange'\n    }\n}\n\nexport default Wheel;"]},"metadata":{},"sourceType":"module"}