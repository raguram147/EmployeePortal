{"ast":null,"code":"var _jsxFileName = \"/home/raguram_s/Desktop/lister/src/components/Wheel.js\";\nimport React from 'react';\nimport Card from './Card.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass Wheel extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.handle_scroll = event => {\n      if (this.state.snap_in_progress && !this.state.loaded) {\n        return;\n      } else {\n        clearTimeout(this.anim_id);\n        this.temp_theta = 180;\n        this.wheel.style.animation = 'spin 5s';\n        this.wheel.style.animationDuration = '5s';\n        this.wheel.style.animationTimingFunction = 'ease';\n        this.wheel.style.animationIterationCount = 'infinite';\n        this.wheel.style.transitionDelay = '0.0s';\n        this.wheel.style.transitionDuration = '0.0s';\n        this.wheel.style.transform = `translate(-50%, -50%) rotate(45deg)`; // this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.temp_theta + (event.deltaY * 0.5)}deg)`;\n        // this.temp_theta += (event.deltaY * 0.5);\n\n        this.anim_id = setTimeout(() => {\n          this.setState({\n            theta: this.temp_theta,\n            snap_in_progress: true\n          }, () => {\n            this.snap_back();\n          });\n        }, 150);\n      }\n    };\n\n    this.children_loaded = () => {\n      this.setState(prevState => {\n        return {\n          children_loaded: prevState.children_loaded + 1\n        };\n      }, () => {\n        if (this.state.children_loaded === 8) {\n          this.setState({\n            loaded: true,\n            snap_point: {\n              x: this.wheel.children[2].getBoundingClientRect().x + this.wheel.children[2].getBoundingClientRect().width / 2,\n              y: this.wheel.children[2].getBoundingClientRect().y + this.wheel.children[2].getBoundingClientRect().height / 2\n            }\n          });\n        }\n      });\n    };\n\n    this.snap_back = () => {\n      let center_of_wheel = {\n        x: this.wheel.getBoundingClientRect().x + this.wheel.getBoundingClientRect().width / 2,\n        y: this.wheel.getBoundingClientRect().y + this.wheel.getBoundingClientRect().height / 2\n      };\n      let snap_point_theta = Math.atan2(Math.abs(this.state.snap_point.y - center_of_wheel.y), Math.abs(this.state.snap_point.x - center_of_wheel.x));\n      snap_point_theta = snap_point_theta * (180 / Math.PI);\n      let shortest_distance = Math.pow(this.wheel.children[3].getBoundingClientRect().x + 100 - this.state.snap_point.x, 2) + Math.pow(this.wheel.children[3].getBoundingClientRect().y + 100 - this.state.snap_point.y, 2);\n      shortest_distance = Math.sqrt(shortest_distance);\n      let closest_card = null; // loop through all cards and compare distances to snap_point; find shortest distance\n\n      for (let i = 0; i < this.wheel.children.length; i++) {\n        let dx = this.wheel.children[i].getBoundingClientRect().x + 100 - this.state.snap_point.x;\n        let dy = this.wheel.children[i].getBoundingClientRect().y + 100 - this.state.snap_point.y;\n        let current_distance = Math.pow(dx, 2) + Math.pow(dy, 2);\n        current_distance = Math.sqrt(current_distance);\n\n        if (shortest_distance >= current_distance) {\n          shortest_distance = current_distance;\n          closest_card = this.wheel.children[i];\n        }\n      } // find angle between snap_point's theta and closest_card's theta\n\n\n      let closest_cards_x = closest_card.getBoundingClientRect().x + closest_card.getBoundingClientRect().width / 2;\n      let closest_cards_y = closest_card.getBoundingClientRect().y + closest_card.getBoundingClientRect().height / 2;\n      let closest_cards_theta = Math.atan2(Math.abs(closest_cards_y - center_of_wheel.y), Math.abs(closest_cards_x - center_of_wheel.x));\n      closest_cards_theta = closest_cards_theta * (180 / Math.PI);\n      let theta_between = Math.abs(closest_cards_theta - snap_point_theta); // decide whether to make a positive or negative degree shift\n\n      if (closest_cards_x > center_of_wheel.x && closest_cards_y <= center_of_wheel.y) {\n        // QI\n        theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n      } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y <= center_of_wheel.y) {\n        // QII\n        theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n      } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y > center_of_wheel.y) {\n        // QIII\n        theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n      } else if (closest_cards_x > center_of_wheel.x && closest_cards_y >= center_of_wheel.y) {\n        // QIV\n        theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n      } // rotate wheel towards snap point\n\n\n      this.wheel.style.transitionDelay = '0.1s';\n      this.wheel.style.transitionDuration = '1.0s';\n      this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.state.theta + theta_between}deg)`; // rotate the cards in the opposite direction of the wheel to maintain equilibrium\n\n      for (let i = 0; i < this.wheel.children.length; i++) {\n        this.wheel.children[i].style.transitionDelay = '0.1s';\n        this.wheel.children[i].style.transitionDuration = '1.0s';\n\n        if (closest_card === this.wheel.children[i]) {\n          this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(1.0)`;\n          this.wheel.children[i].style.zIndex = 100;\n        } else {\n          this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(0.5)`;\n          this.wheel.children[i].style.zIndex = 1;\n        }\n      }\n\n      setTimeout(() => {\n        this.setState(prevState => {\n          return {\n            snap_in_progress: false,\n            theta: prevState.theta + theta_between\n          };\n        });\n      }, 200);\n    };\n\n    this.state = {\n      radius: 150,\n      cards: [],\n      theta: 0.0,\n      snap_point: {\n        x: null,\n        y: null\n      },\n      snap_in_progress: false,\n      children_loaded: 0,\n      loaded: false\n    };\n    this.temp_theta = 0.0;\n    this.anim_id = null;\n  }\n\n  componentDidMount() {\n    let center_of_wheel = {\n      x: parseFloat(this.wheel.style.width) / 2,\n      y: parseFloat(this.wheel.style.height) / 2\n    };\n    let temp_cards = [];\n\n    for (let i = 0; i < 8; i++) {\n      temp_cards.push(\n      /*#__PURE__*/\n      // <Card radius={this.state.radius} theta={(Math.PI / 4) * i} center={center_of_wheel} key={`card_${i}`} pic={`./${i}-200x200.jpg`} amLoaded={this.children_loaded} />\n      _jsxDEV(Card, {\n        radius: this.state.radius,\n        theta: Math.PI / 4 * i,\n        center: center_of_wheel,\n        pic: `https://picsum.photos/500/500`,\n        amLoaded: this.children_loaded\n      }, `card_${i}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 17\n      }, this));\n    }\n\n    this.setState({\n      cards: temp_cards\n    });\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      onWheel: this.handle_scroll,\n      ref: ref_id => this.wheel = ref_id,\n      style: styles.wheel,\n      children: this.state.cards\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 164,\n      columnNumber: 13\n    }, this);\n  }\n\n}\n\nconst styles = {\n  wheel: {\n    margin: '70px',\n    height: '100px',\n    width: '100px',\n    borderRadius: '50%',\n    position: 'absolute',\n    transform: 'translate(-50%, -50%)',\n    backgroundColor: '#EF6E25',\n    animation: 'spin 5s',\n    animationDuration: '5s',\n    animationTimingFunction: 'ease',\n    animationIterationCount: 'infinite'\n  }\n};\nexport default Wheel;","map":{"version":3,"sources":["/home/raguram_s/Desktop/lister/src/components/Wheel.js"],"names":["React","Card","Wheel","Component","constructor","props","handle_scroll","event","state","snap_in_progress","loaded","clearTimeout","anim_id","temp_theta","wheel","style","animation","animationDuration","animationTimingFunction","animationIterationCount","transitionDelay","transitionDuration","transform","setTimeout","setState","theta","snap_back","children_loaded","prevState","snap_point","x","children","getBoundingClientRect","width","y","height","center_of_wheel","snap_point_theta","Math","atan2","abs","PI","shortest_distance","pow","sqrt","closest_card","i","length","dx","dy","current_distance","closest_cards_x","closest_cards_y","closest_cards_theta","theta_between","zIndex","radius","cards","componentDidMount","parseFloat","temp_cards","push","render","ref_id","styles","margin","borderRadius","position","backgroundColor"],"mappings":"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","sourcesContent":["import React from 'react'\n\nimport Card from './Card.js';\n\n\nclass Wheel extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            radius: 150,\n            cards: [],\n            theta: 0.0,\n            snap_point: { x: null, y: null },\n            snap_in_progress: false,\n            children_loaded: 0,\n            loaded: false,\n        }\n\n        this.temp_theta = 0.0;\n        this.anim_id = null;\n    }\n\n    componentDidMount() {\n        let center_of_wheel = {\n            x: parseFloat(this.wheel.style.width) / 2,\n            y: parseFloat(this.wheel.style.height) / 2\n        }\n        let temp_cards = [];\n\n        for (let i = 0; i < 8; i++) {\n            temp_cards.push(\n                // <Card radius={this.state.radius} theta={(Math.PI / 4) * i} center={center_of_wheel} key={`card_${i}`} pic={`./${i}-200x200.jpg`} amLoaded={this.children_loaded} />\n                <Card radius={this.state.radius} theta={(Math.PI / 4) * i} center={center_of_wheel} key={`card_${i}`} pic={`https://picsum.photos/500/500`} amLoaded={this.children_loaded} />\n            );\n        }\n\n        this.setState({ cards: temp_cards });\n    }\n\n    handle_scroll = event => {\n        if (this.state.snap_in_progress && !this.state.loaded) {\n            return;\n        } else {\n            clearTimeout(this.anim_id);\n            this.temp_theta =180;\n            this.wheel.style.animation='spin 5s';\n            this.wheel.style.animationDuration= '5s';\n            this.wheel.style.animationTimingFunction= 'ease';\n            this.wheel.style.animationIterationCount= 'infinite';\n            this.wheel.style.transitionDelay = '0.0s';\n            this.wheel.style.transitionDuration = '0.0s';\n            this.wheel.style.transform = `translate(-50%, -50%) rotate(45deg)`;\n            // this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.temp_theta + (event.deltaY * 0.5)}deg)`;\n            // this.temp_theta += (event.deltaY * 0.5);\n\n            \n\n            this.anim_id = setTimeout(() => {\n                this.setState({ theta: this.temp_theta, snap_in_progress: true }, () => {\n                    this.snap_back();\n                });\n            }, 150);\n        }\n    }\n\n    children_loaded = () => {\n        this.setState(prevState => {\n            return {\n                children_loaded: prevState.children_loaded + 1\n            }\n        }, () => {\n            if (this.state.children_loaded === 8) {\n                this.setState({\n                    loaded: true,\n                    snap_point: {\n                        x: this.wheel.children[2].getBoundingClientRect().x + (this.wheel.children[2].getBoundingClientRect().width / 2),\n                        y: this.wheel.children[2].getBoundingClientRect().y + (this.wheel.children[2].getBoundingClientRect().height / 2),\n                    }\n                });\n            }\n        });\n    }\n\n    snap_back = () => {\n        let center_of_wheel = {\n            x: this.wheel.getBoundingClientRect().x + (this.wheel.getBoundingClientRect().width / 2),\n            y: this.wheel.getBoundingClientRect().y + (this.wheel.getBoundingClientRect().height / 2)\n        }\n        let snap_point_theta = Math.atan2(Math.abs(this.state.snap_point.y - center_of_wheel.y), Math.abs(this.state.snap_point.x - center_of_wheel.x));\n        snap_point_theta = snap_point_theta * (180 / Math.PI);\n\n        let shortest_distance =\n            Math.pow(((this.wheel.children[3].getBoundingClientRect().x + 100) - this.state.snap_point.x), 2) +\n            Math.pow(((this.wheel.children[3].getBoundingClientRect().y + 100) - this.state.snap_point.y), 2);\n        shortest_distance = Math.sqrt(shortest_distance);\n\n        let closest_card = null;\n\n        // loop through all cards and compare distances to snap_point; find shortest distance\n        for (let i = 0; i < this.wheel.children.length; i++) {\n            let dx = (this.wheel.children[i].getBoundingClientRect().x + 100) - this.state.snap_point.x;\n            let dy = (this.wheel.children[i].getBoundingClientRect().y + 100) - this.state.snap_point.y;\n            let current_distance = Math.pow(dx, 2) + Math.pow(dy, 2);\n            current_distance = Math.sqrt(current_distance)\n\n            if (shortest_distance >= current_distance) {\n                shortest_distance = current_distance;\n                closest_card = this.wheel.children[i];\n            }\n        }\n\n        // find angle between snap_point's theta and closest_card's theta\n        let closest_cards_x = closest_card.getBoundingClientRect().x + (closest_card.getBoundingClientRect().width / 2);\n        let closest_cards_y = closest_card.getBoundingClientRect().y + (closest_card.getBoundingClientRect().height / 2);\n\n        let closest_cards_theta = Math.atan2(Math.abs(closest_cards_y - center_of_wheel.y), Math.abs(closest_cards_x - center_of_wheel.x));\n        closest_cards_theta = closest_cards_theta * (180 / Math.PI);\n\n        let theta_between = Math.abs(closest_cards_theta - snap_point_theta);\n\n        // decide whether to make a positive or negative degree shift\n        if (closest_cards_x > center_of_wheel.x && closest_cards_y <= center_of_wheel.y) { // QI\n            theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n        } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y <= center_of_wheel.y) { // QII\n            theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n        } else if (closest_cards_x <= center_of_wheel.x && closest_cards_y > center_of_wheel.y) { // QIII\n            theta_between = closest_cards_theta > snap_point_theta ? theta_between : -1.0 * theta_between;\n        } else if (closest_cards_x > center_of_wheel.x && closest_cards_y >= center_of_wheel.y) { // QIV\n            theta_between = closest_cards_theta > snap_point_theta ? -1.0 * theta_between : theta_between;\n        }\n\n        // rotate wheel towards snap point\n        this.wheel.style.transitionDelay = '0.1s';\n        this.wheel.style.transitionDuration = '1.0s';\n        this.wheel.style.transform = `translate(-50%, -50%) rotate(${this.state.theta + theta_between}deg)`;\n\n        // rotate the cards in the opposite direction of the wheel to maintain equilibrium\n        for (let i = 0; i < this.wheel.children.length; i++) {\n            this.wheel.children[i].style.transitionDelay = '0.1s';\n            this.wheel.children[i].style.transitionDuration = '1.0s';\n\n            if (closest_card === this.wheel.children[i]) {\n                this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(1.0)`;\n                this.wheel.children[i].style.zIndex = 100;\n            } else {\n                this.wheel.children[i].style.transform = `translate(-50%, -50%) rotate(${-1.0 * (this.state.theta + theta_between)}deg) scale(0.5)`;\n                this.wheel.children[i].style.zIndex = 1;\n            }\n        }\n\n        setTimeout(() => {\n            this.setState(prevState => {\n                return {\n                    snap_in_progress: false,\n                    theta: prevState.theta + theta_between\n                }\n            });\n        }, 200);\n    }\n\n    render() {\n        return (\n            <div onWheel={this.handle_scroll} ref={ref_id => this.wheel = ref_id} style={styles.wheel}>\n                {this.state.cards}\n            </div>\n        )\n\n    }\n}\n\nconst styles = {\n    wheel: {\n        margin:'70px',\n        height: '100px',\n        width: '100px',\n        borderRadius: '50%',\n        position: 'absolute',\n        transform: 'translate(-50%, -50%)',\n        backgroundColor: '#EF6E25',\n        animation: 'spin 5s',\n        animationDuration: '5s',\n        animationTimingFunction: 'ease',\n    animationIterationCount: 'infinite'\n    }\n}\n\nexport default Wheel;"]},"metadata":{},"sourceType":"module"}